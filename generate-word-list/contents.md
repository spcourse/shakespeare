# Generate wordlist (BONUS)

In the previous assignment, you used the files `shakespeare-words.txt` and `shakespeare-tf-idf.csv`. The first file contains a list of words that were said to be typical for Shakespearean writing. The second file contains a word list with TF-IDF scores that reflect how characteristic each word is for Shakespearean writing.

The goal here is to create a similar one of these files yourself. To do this, you'll use another set of text fragments known as the 'training set'. This set includes text fragments written by both Shakespeare and other authors. These text fragments are similar to the ones in the previous assignment but not exactly the same.

> Note: What you're doing here involves using two different sets of data: a 'training set' and a 'test set'. This is a technique frequently used in machine learning. You use the 'training set' to create a model, and the 'test set' to evaluate its performance. Often, these two sets are generated by taking a larger dataset and splitting it randomly into these two parts. In this case, you use the 'training set' to generate a list of words typical of Shakespeare, and the 'test set' to assess how well your algorithm works with this specific list of Shakespearean words. (The evaluation you've already done in the previous assignments, so for this assignment we will only focus on the training set.)

You can choose yourself which of the two word lists you want to generate, 1) the unique words or 2) the TF-IDF scores. Option 2 is slightly harder that option 2.

## Option 1: Generate unique word list

Your task is to find the words that appear in the text fragments written by Shakespeare but are not present in any of the other text fragments.


Create a file named `generate-word-list.py`. In this file, you will develop an algorithm that performs the following steps. (**You can reuse some a lot of the functions from the previous assignments for these steps. For example: `get_text_file_names`, and `tokenize_text`**.)

1. Identify all text documents within the `training-set` directory.
2. Construct `set`s of words from all the documents.
3. Utilize the sets generated in step 2 to create two larger `set`s: one containing all words from text fragments by Shakespeare (`set` 1), and another containing words from the remaining text fragments (`set` 2). Which set operation would be suitable for this task?
4. Formulate the set of Shakespearean words by selecting words present in set 1 but absent in set 2. Which set operation would be suitable here?
5. Arrange the results in alphabetical order and write them to the file named `my-shakespeare-words.txt`.

You can verify your outcomes by comparing your file to the provided one using the command line `diff` tool. Enter the following command in the console:

    diff shakespeare-words.txt my-shakespeare-words.txt

You can reuse some of the functions from the previous assignment here. Copy the following functions over to `generate-shakespeare-word-list.py`: `get_text_file_names`, and `tokenize_text`.

Just like in the previous assignment, use a `main` function with the following structure:

    def main():
        # main code ...

    # other functions

    if __name__ == "__main__":
        main()

## Option 2: Generate TF-IDF scores

Your task is to compute the TF-IDF score for each word that appears in any text fragment written by Shakespeare.

### TF-IDF

The TF-IDF score consists of two part: _Term Frequency_ (TF - indicating how often a word occurs) and _Inverse Document Frequency_ (IDF - indicating how unique a word is).

The _Term Frequency_ of a word is computed by counting how frequently it occurs in texts of Shakespeare:

$$
TF(word) = \frac{\textrm{number of occurrences of word in all the text fragments written by Shakespeare}}{\textrm{total number of words in all the text fragments written by Shakespeare}}
$$

The _Inverse Document Frequency_ of a word is computed by counting the total number of words in **all** text fragments (so, not only those written by Shakespeare) and dividing this by how often the word occurs in **all** documents and finally taking the log `math.log()` of the result:

$$
IDF(word) = \log(\frac{\mathrm{total number of words in all text fragments}}{\mathrm{number of occurrences of word in all text fragments}})
$$  

The TF-IDF score is computed my multiplying the two scores above:

$$
TF-IDF(word) = TF(word) \times IDF(word)
$$

So in order to be able to compute the TF-IDF scores, you need to count how often it occurs in all text fragments (of both Shakespeare and other authors) and you need to count how often it occurs in the text fragments written by Shakespeare.

### Steps

Create a file named `generate-tf-idf.py`. In this file, you will develop an algorithm that performs the following steps:

1. Create a function `count_words(file_names)`. That given a set of files returns a dictionary with a count for each word in set of files.
2. Identify all text documents within the `training-set` directory and store these in a list called `all_files`. You might want to use `get_text_file_names()` from previous assignments here.
3. Create a list of file_names from `training-set` containing only and store these in a list called `shakespeare_files`. You might want to use `is_written_by_shakespeare()` from previous assignments.
5. Use the `count_words()` function on both `all_files` and `shakespeare_files`, creating two dictionaries `word_count_all` and `word_count_shakespeare`.
6. Write a function called `compute_tf_idf(word_count_all, word_count_shakespeare)` that computes the TF-IDF score of each word based on the given word count dictionaries, the result should be returned as a dictionary.
7. Write the results in comma separated format to the file `my-shakespeare-tf-idf.csv`.

You can verify your outcomes by comparing scores from your `my-shakespeare-tf-idf.csv` to the provided `shakespeare-tf-idf.csv`, however the words are probably not in the same order, so a direct comparison using `diff` will likely not work.

Just like in the previous assignment, use a `main` function with the following structure:


    def main():
        # main code ...

    # other functions

    if __name__ == "__main__":
        main()
